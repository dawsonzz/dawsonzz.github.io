{"pages":[],"posts":[{"title":"多线程初探","text":"线程创建值拷贝类型12345678910111213void printAll(int a, int b, int c){ std::cout &lt;&lt; a &lt;&lt; \" \" &lt;&lt; b &lt;&lt; \" \" &lt;&lt; c &lt;&lt; std::endl;}void testThreadInit() { int a = 3; int b = 4; int c = 5; std::thread t1([=]{printAll(a, b, c);}); t1.join(); std::thread t2(printAll, a, b, c); t2.join();} 这两种创建方式都是值拷贝，但是t2比t1效率高点，t1多了一步从lambda生成的过程 引用类型12345678910111213void add(int a, int b, int&amp; c){ c = a + b;}void testThreadInit2() { int a = 3; int b = 4; int c = 5; std::thread t3([=, &amp;c]{add(a, b, c);}); t3.join(); std::thread t4(add, a, b, std::ref(c)); t4.join();} 由于t4这中创建是值拷贝的，需要使用std::ref来转化为引用 12std::ref //引用std::cref //常量引用 12345678910111213void pirntString(const std::string&amp; info, const std::string&amp; info2){ std::cout&lt;&lt; info &lt;&lt; \" \" &lt;&lt; info2 &lt;&lt;std::endl;}void testThreadInit3() { std::string hello(\"hello\"); std::string world(\"world\"); std::thread t5([&amp;]{pirntString(hello, world);}); //引用 t5.join(); std::thread t6(pirntString, hello, world); //值拷贝 t6.join(); std::thread t7(pirntString, std::cref(hello), std::cref(world)); //引用 t7.join();} 线程间数据操作独立变量将共享变量拆分为独立变量，这种方法具有局限性，有些变量没办法拆开，最后再累加 原子操作12std::atomic&lt;int&gt; count=0;std::atomic_int count2=0; 使得多个线程访问时不会打断count++等操作，但是原子操作之前还是可能发生线程切换的情况。 锁123456789class Counter {public: void addCount() {m_count++;} void lockMutex() {m_mutex.lock();} //加锁 void unlockMutex() {m_mutex.unlock();} //解锁private: std::atomic&lt;int&gt; m_count; std::mutex m_mutex; //锁} 死锁调用了两次加锁而没有解锁,常见情况 函数写得太独立，嵌套加锁 123456789101112void debug(Counter&amp; c){ c.lockMutex(); std::cout&lt;&lt;\"debug\"&lt;&lt;std::endl; c.unlockMutex();}void work(Counter&amp; c){ c.lockMutex(); std::cout&lt;&lt;\"work\"&lt;&lt;std::endl; debug(c); //这里没有解锁导致死锁 c.unlockMutex();} throw异常跳过解锁 123456789101112void bug(){ throw \"bad\";}void work(Counter&amp; c){ try{ c.lockMutex(); std::cout&lt;&lt;\"work\"&lt;&lt;std::endl; bug(); c.unlockMutex(); //解锁被跳过 } catch(...){}} 使用优化原始手动加解锁 123456int count() { m_mutex.lock(); auto r = m_count; m_mutex.unlock(); return r;}//一次次加锁解锁操作使得代码冗杂 利用类的在作用域存活周期来实现自动加解锁 12345678910111213template&lt;typename T&gt;class Lock{public: Lock(T&amp; mutex): m_mutex(mutex) {m_mutex.lock();} ~Lock() {m_mutex.unlock();}private: T&amp; m_mutex;}int count() { Lock&lt;std::mutex&gt; lock(m_mutex); return m_count;} 使用STL中的std::lock_guard，使用起来更加灵活 12345678910class Counter {public: void addCount() { std::lock_guard&lt;std::mutex&gt; lock(m_mutex); m_count++; }private: std::atomic&lt;int&gt; m_count; std::mutex m_mutex; //锁} lock_guard灵活的地方 123456789101112131415161718192021222324252627282930313233343536struct BankAccount { BankAccount(int b) : Balance(b) {} int Balance; std::mutex Mutex;};void transferMoney(BankAccount&amp; a, BankAccount&amp; b, int money){ if(&amp;a == &amp;b) return; std::lock_guard&lt;std::mutex&gt; lockA(a.Mutex); std::lock_guard&lt;std::mutex&gt; lockB(b.Mutex); if(a.Balance &lt;= money) return; a.Balance -= money; b.Balance += money;}/* 死锁情况thread1transferMoney(a, b, 10);thread2transferMoney(b, a, 10);粗暴解决方法：判断a，b的地址，先加锁地址小的变量，缺点是代码冗杂*/void transferMoneySTL(BankAccount&amp; a, BankAccount&amp; b, int money){ if(&amp;a == &amp;b) return; std::lock(a.Mutex, b.Mutex /*....*/); //只加锁 还需要解锁 std::lock_guard&lt;std::mutex&gt; lockA(a.Mutex, std::adpot_lock); std::lock_guard&lt;std::mutex&gt; lockB(b.Mutex, std::adpot_lock); //std::adpot_lock 让lock_guard 知道已经加锁了，只需要析构的时候解锁 if(a.Balance &lt;= money) return; a.Balance -= money; b.Balance += money;} 线程结束123456789101112131415161718class Obj(){public: Obj(){std::cout&lt;&lt;\"hello \"&lt;&lt;std::endl;} ~Obj(){std::cout&lt;&lt;\"world \"&lt;&lt;std::endl;}};void method(){}void detachWorker() { Obj obj(); std::this_thread::sleep_for(std::chrono::seconds(1));}int main(){ std::thread a(method); std::thread b(detachWorker); a.join(); //阻塞线程，主线程等待线程结束 b.detach(); //主线程结束就结束，obj的析构函数来不及调用 return 0;}","link":"/2020/01/13/atomic/"},{"title":"线程等待","text":"休眠等待123456789101112131415161718192021222324252627282930std::mutex mutex;std::atomic&lt;bool&gt; ready{false};void worker(int i){ while(!ready){ //等待 //第一种：释放占用的核给其他线程，如果线程数多于核心数，可能没有什么效果 std::this_thread::yield(); //第二种： //std::this_thread::sleep_for(std::chrono::seconds(1)); }}int main() { const auto threadCount = 4; std::vector&lt;std::thread&gt; pool; //线程池 for(int i=0; i&lt; threadCount; i++){ pool.emplace_book(worker, i);//不需要触发拷贝构造和转移构造 /*等价pool.push_back(std::thread(worker,i)); 在引入右值引用，转移构造函数，转移复制运算符之前，通常使用push_back()向容器中加入一个右值元素（临时对象）的时候，首先会调用构造函数构造这个临时对象，然后需要调用拷贝构造函数将这个临时对象放入容器中。原来的临时变量释放。这样造成的问题是临时变量申请的资源就浪费。 */ } std::this_thread::sleep_for(std::chrono::seconds(100)); ready = true; for(auto &amp;v: pool){ if(v.joinable()) v.join(); }} 使用condition_variable1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556//来自c++文档#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;thread&gt;#include &lt;mutex&gt;#include &lt;condition_variable&gt; std::mutex m;std::condition_variable cv;std::string data;bool ready = false;bool processed = false; void worker_thread(){ // Wait until main() sends data // std::lock_guard&lt;std::mutex&gt; lk(m)获得锁，并在析构时释放 std::unique_lock&lt;std::mutex&gt; lk(m); //获得锁，要与condition_variable配合 cv.wait(lk, []{return ready;}); //释放锁，并在这里阻塞，当condition_variable获得通知，判断{return ready;}是否满足，如果满足，获得锁并继续执行 // after the wait, we own the lock. std::cout &lt;&lt; \"Worker thread is processing data\\n\"; data += \" after processing\"; // Send data back to main() processed = true; std::cout &lt;&lt; \"Worker thread signals data processing completed\\n\"; // Manual unlocking is done before notifying, to avoid waking up // the waiting thread only to block again (see notify_one for details) lk.unlock(); cv.notify_one();} int main(){ std::thread worker(worker_thread); data = \"Example data\"; // send data to the worker thread { std::lock_guard&lt;std::mutex&gt; lk(m); ready = true; std::cout &lt;&lt; \"main() signals data ready for processing\\n\"; } cv.notify_one(); // wait for the worker { std::unique_lock&lt;std::mutex&gt; lk(m); cv.wait(lk, []{return processed;}); } std::cout &lt;&lt; \"Back in main(), data = \" &lt;&lt; data &lt;&lt; '\\n'; worker.join();} output: 1234main() signals data ready for processingWorker thread is processing dataWorker thread signals data processing completedBack in main(), data = Example data after processing","link":"/2020/01/14/thread-waiting/"}],"tags":[{"name":"c++","slug":"c","link":"/tags/c/"},{"name":"thread","slug":"thread","link":"/tags/thread/"},{"name":"atomic","slug":"atomic","link":"/tags/atomic/"},{"name":"mutex","slug":"mutex","link":"/tags/mutex/"},{"name":"condition_variable","slug":"condition-variable","link":"/tags/condition-variable/"}],"categories":[]}